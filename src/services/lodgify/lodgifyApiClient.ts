/**
 * Lodgify API Client Module
 * 
 * Main synchronization functions for sending pricing data to Lodgify API.
 * Integrates authentication, validation, retry logic, and logging.
 */

import { 
  LodgifySyncResult,
  LodgifySyncError,
  SyncOptions, 
  BatchSyncPayload,
  BatchSyncResult,
  LodgifyApiError,
  LODGIFY_API_CONSTANTS,
  isTimeoutError
} from './lodgifyTypes'
import { buildAuthHeaders, getIntegrationConfig } from './lodgifyAuth'
import { validateLodgifyPayload, sanitizeLodgifyPayload } from './lodgifyValidation'
import { makeRequestWithRetry, createTimeoutSignal } from './lodgifyRetry'
import { logger } from './lodgifyLogger'

/**
 * Default sync options
 */
const DEFAULT_SYNC_OPTIONS: SyncOptions = {
  timeout: LODGIFY_API_CONSTANTS.DEFAULT_TIMEOUT,
  maxRetries: LODGIFY_API_CONSTANTS.MAX_RETRIES,
  validatePayload: true
}

/**
 * Main function to sync pricing data to Lodgify
 * 
 * @param propertyId - UUID of the property in database
 * @param pricingPayload - Payload generated by Task 14a
 * @param options - Sync options (optional)
 * @returns Sync result with success status and details
 */
export async function syncPricingToLodgify(
  propertyId: string,
  pricingPayload: unknown,
  options: SyncOptions = {}
): Promise<LodgifySyncResult> {
  const syncOptions = { ...DEFAULT_SYNC_OPTIONS, ...options }
  const startTime = Date.now()
  let retryCount = 0

  try {
    // Check if integration is enabled
    const integrationConfig = await getIntegrationConfig(propertyId)
    if (!integrationConfig?.syncEnabled) {
      throw new LodgifyApiError(
        `Sync is disabled for property ${propertyId}`,
        'validation',
        undefined,
        false
      )
    }

    // Sanitize payload to fix minor type issues
    const sanitizedPayload = sanitizeLodgifyPayload(pricingPayload)

    // Validate payload structure if requested
    if (syncOptions.validatePayload) {
      const validationResult = validateLodgifyPayload(sanitizedPayload)
      
      logger.logValidation(
        propertyId,
        validationResult.valid,
        validationResult.errors,
        validationResult.warnings
      )

      if (!validationResult.valid) {
        throw new LodgifyApiError(
          `Payload validation failed: ${validationResult.errors.join(', ')}`,
          'validation',
          undefined,
          false,
          validationResult.errors
        )
      }
    }

    // Build authentication headers
    const headers = await buildAuthHeaders(propertyId)

    // Determine API endpoint
    const apiUrl = integrationConfig?.apiEndpoint || LODGIFY_API_CONSTANTS.ENDPOINT

    // Log the outgoing request
    logger.logRequest(propertyId, apiUrl, headers, sanitizedPayload)

    // Create timeout signal
    const timeoutSignal = createTimeoutSignal(syncOptions.timeout || LODGIFY_API_CONSTANTS.DEFAULT_TIMEOUT)

    // Make the API request with retry logic
    const response = await makeRequestWithRetry(
      apiUrl,
      {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(sanitizedPayload),
        signal: timeoutSignal
      },
      {
        maxRetries: syncOptions.maxRetries,
        baseDelay: LODGIFY_API_CONSTANTS.BASE_DELAY,
        maxDelay: LODGIFY_API_CONSTANTS.MAX_DELAY,
        retryableStatuses: LODGIFY_API_CONSTANTS.RETRYABLE_STATUSES
      }
    )

    const duration = Date.now() - startTime
    const responseText = await response.text()
    let responseData: any

    try {
      responseData = responseText ? JSON.parse(responseText) : {}
    } catch (e) {
      // Response is not JSON, use text
      responseData = { message: responseText }
    }

    // Log the response
    logger.logResponse(
      propertyId,
      response.status,
      duration,
      responseText.length,
      responseData
    )

    // Check for success
    if (!response.ok) {
      throw new LodgifyApiError(
        `API returned error status ${response.status}: ${responseData?.message || response.statusText}`,
        'api',
        response.status,
        false,
        responseData
      )
    }

    return {
      success: true,
      propertyId,
      statusCode: response.status,
      message: responseData?.message || 'Pricing data successfully synced to Lodgify',
      requestId: responseData?.requestId,
      timestamp: new Date().toISOString(),
      retryCount,
      duration
    }

  } catch (error) {
    const duration = Date.now() - startTime
    logger.logError(propertyId, error as Error, retryCount)

    // Categorize error type for better handling
    let errorType: LodgifySyncError['type']
    let recoverable = false
    let errorMessage = 'Unknown error occurred'

    if (error instanceof LodgifyApiError) {
      errorType = error.type
      recoverable = error.recoverable || false
      errorMessage = error.message
    } else if (error instanceof Error) {
      if (error.message.includes('API key')) {
        errorType = 'auth'
        errorMessage = error.message
      } else if (error.message.includes('Payload') || error.message.includes('validation')) {
        errorType = 'validation'
        errorMessage = error.message
      } else if (isTimeoutError(error)) {
        errorType = 'timeout'
        recoverable = true
        errorMessage = `Request timeout after ${syncOptions.timeout}ms`
      } else if (error.message.includes('HTTP 429') || error.message.includes('HTTP 5')) {
        errorType = 'api'
        recoverable = true
        errorMessage = error.message
      } else {
        errorType = 'network'
        recoverable = true
        errorMessage = error.message
      }
    } else {
      errorType = 'network'
      errorMessage = String(error)
    }

    return {
      success: false,
      propertyId,
      message: `Failed to sync pricing to Lodgify: ${errorMessage}`,
      timestamp: new Date().toISOString(),
      retryCount,
      duration,
      error: {
        type: errorType,
        details: errorMessage,
        recoverable
      }
    }
  }
}

/**
 * Syncs multiple properties to Lodgify in batch
 * Processes sequentially to respect rate limits
 * 
 * @param propertyPayloads - Array of property IDs and their payloads
 * @param options - Sync options (optional)
 * @returns Batch sync result with individual results and summary
 */
export async function syncMultiplePropertiesToLodgify(
  propertyPayloads: BatchSyncPayload[],
  options: SyncOptions = {}
): Promise<BatchSyncResult> {
  const startTime = Date.now()
  const results: LodgifySyncResult[] = []
  let successful = 0
  let failed = 0

  logger.logBatchSummary(propertyPayloads.length, 0, 0, 0)

  // Process properties sequentially to respect rate limits
  for (let i = 0; i < propertyPayloads.length; i++) {
    const { propertyId, payload } = propertyPayloads[i]
    
    try {
      console.log(`Processing property ${i + 1}/${propertyPayloads.length}: ${propertyId}`)
      
      const result = await syncPricingToLodgify(propertyId, payload, options)
      results.push(result)
      
      if (result.success) {
        successful++
      } else {
        failed++
      }

      // Add delay between requests to be respectful of API rate limits
      // Skip delay for last property
      if (i < propertyPayloads.length - 1) {
        await sleep(LODGIFY_API_CONSTANTS.BATCH_DELAY)
      }
      
    } catch (error) {
      // This shouldn't happen as syncPricingToLodgify catches all errors
      // but just in case...
      failed++
      results.push({
        success: false,
        propertyId,
        message: `Unexpected batch sync error: ${(error as Error).message}`,
        timestamp: new Date().toISOString(),
        retryCount: 0,
        duration: Date.now() - startTime,
        error: {
          type: 'network',
          details: (error as Error).message,
          recoverable: true
        }
      })
    }
  }

  const totalDuration = Date.now() - startTime
  logger.logBatchSummary(propertyPayloads.length, successful, failed, totalDuration)

  return {
    totalProperties: propertyPayloads.length,
    successful,
    failed,
    results,
    duration: totalDuration,
    summary: `Batch sync completed: ${successful}/${propertyPayloads.length} successful, ${failed} failed`
  }
}

/**
 * Tests connection to Lodgify API for a property
 * Sends a minimal payload to verify authentication and endpoint
 * 
 * @param propertyId - UUID of the property
 * @returns Test result
 */
export async function testLodgifyConnection(propertyId: string): Promise<LodgifySyncResult> {
  // Get property details from database to build test payload
  const { supabase } = await import('@/lib/supabase')
  
  const { data: property, error } = await supabase
    .from('properties')
    .select('lodgify_property_id, lodgify_room_type_id, base_price_per_day')
    .eq('id', propertyId)
    .single()

  if (error || !property) {
    throw new LodgifyApiError(
      `Property not found: ${propertyId}`,
      'validation',
      undefined,
      false
    )
  }

  // Create minimal test payload
  const testPayload = {
    property_id: parseInt(property.lodgify_property_id),
    room_type_id: property.lodgify_room_type_id ? parseInt(String(property.lodgify_room_type_id)) : undefined,
    rates: [
      {
        is_default: true,
        price_per_day: property.base_price_per_day,
        min_stay: 1,
        max_stay: 30,
        price_per_additional_guest: 0,
        additional_guests_starts_from: 1
      }
    ]
  }

  console.log('Testing Lodgify connection with minimal payload...')
  return syncPricingToLodgify(propertyId, testPayload, {
    validatePayload: true,
    maxRetries: 0, // No retries for test
    timeout: 10000 // 10 second timeout for test
  })
}

/**
 * Helper function to sleep for a specified duration
 * 
 * @param ms - Milliseconds to sleep
 */
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms))
}

/**
 * Gets sync status for a property
 * Checks if property has valid integration and is enabled
 * 
 * @param propertyId - UUID of the property
 * @returns Status object
 */
export async function getPropertySyncStatus(propertyId: string): Promise<{
  enabled: boolean
  hasApiKey: boolean
  lastSync?: Date
  nextSync?: Date
  errors?: string[]
}> {
  const { verifyApiKeyExists } = await import('./lodgifyAuth')
  const hasApiKey = await verifyApiKeyExists(propertyId)
  
  const integrationConfig = await getIntegrationConfig(propertyId)
  
  return {
    enabled: integrationConfig?.syncEnabled || false,
    hasApiKey,
    // TODO: Implement last/next sync tracking in database
    errors: !hasApiKey ? ['No API key configured'] : undefined
  }
}